.type Id = Add {x : Id, y : Id}
         | Num {n : number}

.decl eql(x : Id, y : Id) eqrel
.decl add(x : Id, y : Id, c : Id) btree_delete
.decl num(x : number, c : Id) btree_delete

// comm-add
eql(xy, yx), 
 add(x, y, xy) :- add(y, x, yx), 
 xy = $Add(x, y).

// assoc-add
eql(xy_z, x_yz), 
 add(x, yz, x_yz), 
 add(y, z, yz) 
 :- 
 add(x, y, xy), add(xy, z, xy_z),
 yz = $Add(y, z), x_yz = $Add(x, yz).

// canonize enodes
// NOTE: we can't use aggregate to populate the smallest leader
// add(x, y, b) :- add(x, y, a), b = min b1 : eql(a, b1).
add(x, y, b) :- eql(a, b), add(x, y, a), as(b, number) < as(a, number).
num(x, b) :- eql(a, b), num(x, a), as(b, number) < as(a, number).

// congruence 
eql(a, b) :- add(x, y, a), add(x, y, b), a != b.
eql(a, b) :- num(n, a), num(n, b), a != b.

// populate eql
eql(c, c) :- num(_, c).
eql(c, c) :- add(_, _, c).

// ordering for canonicalization
add(z, w, a) <= add(x, y, b) :- 
    // Only this works -- This may be a bug in the souffle compiler!!
    // E.g., at the time of comparing, eql has not populated equivalence for y and w
    eql(y, w),
    eql(x, z),
    // although this sounds to always hold by congruence, we need to add eql(a, b), because otherwise the chance that a and b get merged may be missed as a is subsumed.
    eql(a, b), 
    as(x, number) <= as(z, number), 
    as(y, number) <= as(w, number), 
    as(b, number) <= as(a, number).

num(n, a) <= num(n, b) :-
    as(a, number) <= as(b, number).

// insert an expression 1 + 2 + 3
.decl add_prep(x : Id, y : Id, c : Id)
num(1, $Num(1)).
num(2, $Num(2)).
add_prep($Num(2), $Num(1), $Add($Num(2), $Num(1))).
add_prep($Num(x + 1), id, $Add($Num(x + 1), id)), 
 num(x + 1, $Num(x + 1)) 
 :-
 add_prep($Num(x), _, id),
 x <= 3.

add(x, y, c) :- add_prep(x, y, c).
.output add

.decl leader(a : Id, b : Id)
leader(a, as(b, Id)) :- eql(a, _), b = min b1 : { eql(a, b), b1 = as(b, number) }.

.output leader
